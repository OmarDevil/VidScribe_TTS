Index: src/main.py
===================================================================
diff --git a/src/main.py b/src/main.py
deleted file mode 100644
--- a/src/main.py	(revision c74dff641f735561ce702bbdf7d0731017dddaa5)
+++ /dev/null	(revision c74dff641f735561ce702bbdf7d0731017dddaa5)
@@ -1,358 +0,0 @@
-from typing import List, Optional, Dict, Any
-from docx import Document
-from datetime import datetime
-import requests
-import os
-import cv2
-import pytesseract
-import yt_dlp
-from ultralytics import YOLO
-import google.generativeai as genai
-from tqdm import tqdm
-import json
-import time
-from youtube_search import YoutubeSearch
-
-# Constants
-GENAI_API_KEY = "AIzaSyAJexsERXMnXxVd7w5zBiHqy2TiXwU8Gis"
-ELEVENLABS_API_KEY = "sk_9cb8fc1fa8d204870d890050a10f6f5e3fc144e1a6b783fd"
-ELEVENLABS_VOICE_ID = "21m00Tcm4TlvDq8ikWAM"
-
-# Configure Gemini API
-genai.configure(api_key=GENAI_API_KEY)
-
-# Define paths
-VIDEO_FOLDER = os.path.join("..", "video")  # Path to the video folder
-DOWNLOADED_VIDEOS_FOLDER = os.path.join(VIDEO_FOLDER, "downloaded_videos")
-KEYWORDS_FOLDER = os.path.join(VIDEO_FOLDER, "key_words")
-SCRIPTS_FOLDER = os.path.join(VIDEO_FOLDER, "scripts")
-VOICE_OVER_FOLDER = os.path.join(VIDEO_FOLDER, "voice_over")
-
-# Create folders if they don't exist
-os.makedirs(DOWNLOADED_VIDEOS_FOLDER, exist_ok=True)
-os.makedirs(KEYWORDS_FOLDER, exist_ok=True)
-os.makedirs(SCRIPTS_FOLDER, exist_ok=True)
-os.makedirs(VOICE_OVER_FOLDER, exist_ok=True)
-
-
-def generate_voice_over_script(topic: str, lang: str = "en") -> str:
-    """
-    Generate a voice-over script using Gemini API.
-    """
-    fixed_prompt = """
-    Write a 60-second voice-over script for a video on the following topic.
-    The script should be natural, as if someone is reading it aloud, without timings, musical cues, or additional titles.
-    Start the script directly without any title like "Script for YouTube Video".
-    Keep it simple, easy to understand, direct, and professional.
-    Use short sentences and avoid unnecessary details or extra words.
-    """
-    final_prompt = fixed_prompt + "\n\nTopic: " + topic + " in " + lang
-    model = genai.GenerativeModel('gemini-1.5-flash')
-    response = model.generate_content(final_prompt)
-    text = response.text.strip()
-
-    # Remove unwanted titles
-    unwanted_titles = ["Script for YouTube Video", "Voice Over Script"]
-    for title in unwanted_titles:
-        if text.startswith(title):
-            text = text[len(title):].strip()
-
-    return text
-
-
-def save_script_to_docx(text: str, filename: str) -> None:
-    """
-    Save the generated script to a Word document in the scripts folder.
-    """
-    doc = Document()
-    doc.add_paragraph(text)
-    file_path = os.path.join(SCRIPTS_FOLDER, filename)
-    doc.save(file_path)
-    print(f"âœ… Voice Over Script saved as {file_path}")
-
-
-def save_script_to_txt(text: str, filename: str) -> None:
-    """
-    Save the generated script to a text file in the scripts folder.
-    """
-    file_path = os.path.join(SCRIPTS_FOLDER, filename)
-    with open(file_path, "w", encoding="utf-8") as f:
-        f.write(text)
-    print(f"âœ… Voice Over Script saved as {file_path}")
-
-
-def extract_keywords(text: str, main_topic: str) -> List[str]:
-    """
-    Extract important keywords from the script and ensure each keyword contains the main topic only once.
-    """
-    model = genai.GenerativeModel("gemini-1.5-flash")
-    prompt = (f"Extract the most important keywords from the following script and return them as a comma-separated "
-              f"list in English. Ensure each keyword includes '{main_topic}' only once:\n\n{text}")
-
-    response = model.generate_content(prompt)
-    if response.text:
-        # ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ù†Øµ Ø¥Ù„Ù‰ Ù‚Ø§Ø¦Ù…Ø© ÙƒÙ„Ù…Ø§Øª Ù…ÙØªØ§Ø­ÙŠØ©
-        keywords = response.text.strip().split(",")
-
-        # ØªÙ†Ø¸ÙŠÙ Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ù…Ù† Ø§Ù„Ù…Ø³Ø§ÙØ§Øª Ø§Ù„Ø²Ø§Ø¦Ø¯Ø©
-        cleaned_keywords = [kw.strip() for kw in keywords]
-
-        # Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¹Ø¯Ù… ØªÙƒØ±Ø§Ø± main_topic Ù…Ø±ØªÙŠÙ† Ø¯Ø§Ø®Ù„ Ø£ÙŠ ÙƒÙ„Ù…Ø© Ù…ÙØªØ§Ø­ÙŠØ©
-        final_keywords = []
-        for kw in cleaned_keywords:
-            if main_topic.lower() in kw.lower():
-                # Ø¥Ø²Ø§Ù„Ø© Ø§Ù„ØªÙƒØ±Ø§Ø± Ù„Ùˆ ÙˆØ¬Ø¯
-                kw = kw.replace(main_topic, "").strip()
-                kw = f"{main_topic} {kw}".strip()  # Ø¶Ù…Ø§Ù† ÙˆØ¬ÙˆØ¯ Ø§Ù„ÙƒÙ„Ù…Ø© Ø§Ù„Ù…ÙØªØ§Ø­ÙŠØ© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ÙÙŠ Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©
-            else:
-                kw = f"{main_topic} {kw}".strip()  # Ù„Ùˆ Ù…Ø´ Ù…ÙˆØ¬ÙˆØ¯Ø©ØŒ Ù†Ø¶ÙŠÙÙ‡Ø§ Ø¨Ø·Ø±ÙŠÙ‚Ø© Ø·Ø¨ÙŠØ¹ÙŠØ©
-
-            final_keywords.append(kw)
-
-        return final_keywords
-
-    return []
-
-
-def save_keywords(keywords: List[str]) -> str:
-    """
-    Save the extracted keywords to a text file in the key_words folder.
-    """
-    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
-    filename = f"key_words_{timestamp}.txt"
-    file_path = os.path.join(KEYWORDS_FOLDER, filename)
-    with open(file_path, "w", encoding="utf-8") as f:
-        for keyword in keywords:
-            f.write(keyword + "\n")
-    print(f"âœ… Keywords saved in {file_path}")
-    return file_path
-
-
-def search_videos(query: str, max_results=10, max_retries=3) -> List[Dict[str, Any]]:
-    """
-    Search YouTube for videos containing the query in their title.
-    """
-    for attempt in range(max_retries):
-        try:
-            # Ø§Ù„Ø¨Ø­Ø« Ø§Ù„Ø£ÙˆÙ„ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¹Ù†ÙˆØ§Ù† Ø§Ù„ÙƒØ§Ù…Ù„
-            results = YoutubeSearch(query, max_results=max_results).to_json()
-            videos = json.loads(results).get("videos", [])
-
-            # Ù„Ùˆ Ù…ÙÙŠØ´ Ù†ØªØ§Ø¦Ø¬ØŒ Ù†Ø¨Ø­Ø« Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ÙƒÙ„Ù…Ø© Ø§Ù„Ù…ÙØªØ§Ø­ÙŠØ© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ÙÙ‚Ø·
-            if not videos:
-                print(f"âš  No exact match found for '{query}', trying a broader search...")
-                keywords = query.split()  # ØªÙ‚Ø³ÙŠÙ… Ø§Ù„ÙƒÙ„Ù…Ø§Øª Ø§Ù„Ù…ÙØªØ§Ø­ÙŠØ©
-                if len(keywords) > 1:  # Ù„Ùˆ ÙÙŠÙ‡ Ø£ÙƒØ«Ø± Ù…Ù† ÙƒÙ„Ù…Ø©
-                    broad_query = " ".join(keywords[:2])  # Ù†Ø§Ø®Ø¯ Ø£ÙˆÙ„ ÙƒÙ„Ù…ØªÙŠÙ†
-                else:
-                    broad_query = keywords[0]
-
-                results = YoutubeSearch(broad_query, max_results=max_results).to_json()
-                videos = json.loads(results).get("videos", [])
-
-            return videos
-        except Exception as e:
-            print(f"âŒ Attempt {attempt + 1} failed: {e}")
-            time.sleep(2)  # Ø§Ù†ØªØ¸Ø§Ø± Ù‚Ø¨Ù„ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©
-
-    return []  # Ø¥Ø±Ø¬Ø§Ø¹ Ù‚Ø§Ø¦Ù…Ø© ÙØ§Ø±ØºØ© Ù„Ùˆ ÙƒÙ„ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø§Øª ÙØ´Ù„Øª
-
-
-def search_dailymotion_videos(query: str, max_results: int = 10) -> List[Dict[str, Any]]:
-    """
-    Search Dailymotion for videos matching the query.
-    """
-    url = "https://api.dailymotion.com/videos"
-    params = {
-        "search": query,
-        "limit": max_results,
-        "fields": "id,title,duration,url",
-    }
-    response = requests.get(url, params=params)
-    if response.status_code == 200:
-        data = response.json()
-        return [video for video in data.get("list", []) if video.get("duration", float('inf')) <= 60]
-    return []
-
-
-def download_video(video: Dict[str, Any], platform: str = "youtube", output_dir: str = DOWNLOADED_VIDEOS_FOLDER) -> Optional[str]:
-    """
-    Download the given video using yt-dlp.
-    """
-    os.makedirs(output_dir, exist_ok=True)
-
-    if platform == "youtube":
-        video_url = f"https://www.youtube.com{video['url_suffix']}"
-    elif platform == "dailymotion":
-        video_url = video.get("url")
-    else:
-        print(f"âŒ Unsupported platform: {platform}")
-        return None
-
-    # Check if the video is a live stream
-    if is_live_stream(video_url):
-        print(f"âŒ Skipping live stream: {video['title']}")
-        return None
-
-    ydl_opts = {
-        'outtmpl': os.path.join(output_dir, '%(title)s.%(ext)s'),
-        'format': 'bestvideo[height<=480][ext=mp4]/bestvideo[ext=mp4]',  # Ø¬ÙˆØ¯Ø© 480p Ø£Ùˆ Ø§Ù„Ø¬ÙˆØ¯Ø© Ø§Ù„Ù…ØªØ§Ø­Ø©
-    }
-    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
-        ydl.download([video_url])
-    return os.path.join(output_dir, f"{video['title']}.mp4")
-
-
-def is_live_stream(video_url: str) -> bool:
-    """
-    Check if the video is a live stream.
-    """
-    ydl_opts = {
-        'quiet': True,
-        'extract_flat': True,
-    }
-    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
-        info = ydl.extract_info(video_url, download=False)
-        return info.get('is_live', False)
-
-
-def detect_text_in_video(video_path: str) -> bool:
-    """
-    Detect text in video frames using OpenCV and Tesseract OCR.
-    """
-    cap = cv2.VideoCapture(video_path)
-    while cap.isOpened():
-        ret, frame = cap.read()
-        if not ret:
-            break
-        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
-        text = pytesseract.image_to_string(gray)
-        if text.strip():
-            print("âŒ Text detected in video!")
-            cap.release()
-            return True
-    cap.release()
-    return False
-
-
-def detect_logo_in_video(video_path: str) -> bool:
-    """
-    Detect logos or watermarks using YOLOv5su.
-    """
-    model_path = "yolov5su.pt"
-    yolo_model = YOLO("yolov5su.pt")
-    cap = cv2.VideoCapture(video_path)
-    while cap.isOpened():
-        ret, frame = cap.read()
-        if not ret:
-            break
-        results = yolo_model(frame)
-        for result in results:
-            for box in result.boxes:
-                class_name = yolo_model.names[int(box.cls[0])]
-                if class_name in ["logo", "watermark", "text"]:
-                    print(f"âŒ Logo/Watermark detected: {class_name}")
-                    cap.release()
-                    return True
-    cap.release()
-    return False
-
-
-def convert_text_to_speech(text: str, output_file: str) -> None:
-    """
-    Convert text to speech using ElevenLabs API and save it in the voice_over folder.
-    """
-    url = f"https://api.elevenlabs.io/v1/text-to-speech/{ELEVENLABS_VOICE_ID}"
-    headers = {
-        "Accept": "audio/mpeg",
-        "Content-Type": "application/json",
-        "xi-api-key": ELEVENLABS_API_KEY
-    }
-    data = {
-        "text": text,
-        "model_id": "eleven_multilingual_v2",
-        "voice_settings": {
-            "stability": 0.5,
-            "similarity_boost": 0.5
-        }
-    }
-    response = requests.post(url, json=data, headers=headers)
-    response.raise_for_status()
-    file_path = os.path.join(VOICE_OVER_FOLDER, output_file)
-    with open(file_path, 'wb') as f:
-        for chunk in response.iter_content(chunk_size=1024):
-            if chunk:
-                f.write(chunk)
-    print(f"âœ… Audio saved as {file_path}")
-
-
-def main():
-    steps = 4  # Total number of main steps
-    print("\nğŸš€ Starting the process...\n")
-
-    # Step 1: Get User Input Before Starting the Progress Bar
-    topic = input("\nğŸ“Œ Enter your script topic: ")
-
-    # Configure the progress bar with custom styling
-    progress_bar = tqdm(
-        total=steps,
-        desc="ğŸ”„ Progress",
-        colour="green",
-        bar_format="{desc}: {percentage:3.0f}% |{bar}| {n_fmt}/{total_fmt} Steps"
-    )
-
-    # Step 1: Generate Voice Over Script
-    print("\nâœï¸ Generating Voice Over Script...")
-    script_text = generate_voice_over_script(topic)
-    script_filename = datetime.now().strftime("voice_over_%Y%m%d_%H%M%S.docx")
-    save_script_to_docx(script_text, script_filename)
-    progress_bar.update(1)
-
-    # Step 2: Extract Key Sentences
-    print("\nğŸ“‘ Extracting Key Sentences...")
-    key_sentences = extract_keywords(script_text, topic)  # Pass the main topic to include it in keywords
-    keywords_filename = save_keywords(key_sentences)
-    progress_bar.update(1)
-
-    # Step 3: Search and Download Videos
-    print("\nğŸ¥ Searching and Downloading Videos...")
-    keywords = open(keywords_filename, "r", encoding="utf-8").read().splitlines()
-    for keyword in keywords:
-        print(f"ğŸ” Searching for videos with title containing: {keyword}")
-
-        # Ø§Ù„Ø¨Ø­Ø« ÙÙŠ YouTube Ø£ÙˆÙ„Ø§Ù‹
-        videos = search_videos(keyword)
-        if not videos:
-            print(f"âš  No videos found on YouTube, searching on Dailymotion...")
-            videos = search_dailymotion_videos(keyword)  # Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Dailymotion Ø¥Ø°Ø§ Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù†ØªØ§Ø¦Ø¬ ÙÙŠ YouTube
-
-        if not videos:
-            print(f"âŒ No videos found on both platforms for: {keyword}")
-            continue
-
-        for video in videos:
-            platform = "youtube" if "url_suffix" in video else "dailymotion"
-            print(f"â¬‡ Downloading from {platform}: {video['title']} ({video.get('duration', 'N/A')})")
-            video_path = download_video(video, platform)
-            if video_path is None:  # Skip if the video is a live stream
-                continue
-            if detect_text_in_video(video_path) or detect_logo_in_video(video_path):
-                print("âŒ Video contains text or logos, deleting...")
-                os.remove(video_path)
-            else:
-                print("âœ… Video is clean.")
-    progress_bar.update(1)
-
-    # Step 4: Convert Script to Speech
-    print("\nğŸ”Š Converting Script to Speech...")
-    audio_filename = datetime.now().strftime("voice_over_%Y%m%d_%H%M%S.mp3")
-    convert_text_to_speech(script_text, audio_filename)
-    progress_bar.update(1)
-
-    # Close progress bar
-    progress_bar.close()
-    print("\nâœ… Process completed successfully!\n")
-
-
-if __name__ == "__main__":
-    main()
\ No newline at end of file
Index: .idea/vcs.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"VcsDirectoryMappings\">\r\n    <mapping directory=\"$PROJECT_DIR$\" vcs=\"Git\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/vcs.xml b/.idea/vcs.xml
--- a/.idea/vcs.xml	(revision c74dff641f735561ce702bbdf7d0731017dddaa5)
+++ b/.idea/vcs.xml	(date 1742346822020)
@@ -2,5 +2,6 @@
 <project version="4">
   <component name="VcsDirectoryMappings">
     <mapping directory="$PROJECT_DIR$" vcs="Git" />
+    <mapping directory="$PROJECT_DIR$/VidScribe" vcs="Git" />
   </component>
 </project>
\ No newline at end of file
